other refrence = https://harshwillblog.hashnode.dev/learning-java-collection-framework?source=more_articles_bottom_blogs


94. What is Collection framework?
The Collection Framework in Java is a set of interfaces and classes that help manage groups of objects efficiently.
It includes data structures like List, Set, Queue, and Map and provides powerful features for sorting, searching, and manipulating data.

🔹 Major Interfaces in Collection Framework:
| Interface   | Description                                                                 |
|-------------|-----------------------------------------------------------------------------|
| Collection  | Root interface for most data structures (List, Set, Queue)                 |
| List        | Ordered collection (e.g., ArrayList, LinkedList)                           |
| Set         | No duplicate elements (e.g., HashSet, TreeSet)                             |
| Queue       | For holding elements before processing (e.g., PriorityQueue)               |
| Map         | Key-value pairs (not part of Collection but part of the framework)         |


✅ Structure of Java Collection Framework

                 Collection (Interface)                                                
                      |
      ------------------------------------------            
      |                    |                   |
     List                Set                Queue
      |                   |                   |
ArrayList,           HashSet,          PriorityQueue,
LinkedList,          LinkedHashSet,    ArrayDeque
Vector               TreeSet

           Map (Interface)
                 |
    ------------------------------------
    |                |                |
  HashMap     LinkedHashMap       TreeMap
    |
Hashtable (legacy)


+--------------------------+----------------------------------------+-----------------------------------------------------------+--------------------------------------------------------+
| Collection               | When to Use                            | Why It's Suitable    strengths                                     | Weakness                                               |

+--------------------------+----------------------------------------+-----------------------------------------------------------+--------------------------------------------------------+
| ArrayList                | Need order + fast access               | Maintains insertion order and allows random access        | Slow insertion/deletion in the middle                 |
+--------------------------+----------------------------------------+-----------------------------------------------------------+--------------------------------------------------------+
| LinkedList               | Frequent insert/delete                 | Faster insert/delete at both ends or middle               | Slower random/index-based access                      |
+--------------------------+----------------------------------------+-----------------------------------------------------------+--------------------------------------------------------+
| HashSet                  | Uniqueness required                    | Removes duplicates, offers fast lookup                    | No order, no index access, one null element only       |
+--------------------------+----------------------------------------+-----------------------------------------------------------+--------------------------------------------------------+
| TreeSet                  | Sorted + unique elements               | Automatically keeps elements sorted and unique            | Slower than HashSet, no null elements                 |
+--------------------------+----------------------------------------+-----------------------------------------------------------+--------------------------------------------------------+
| HashMap                  | Key-value lookup                       | Fast access by key, no guaranteed order                   | No key ordering, allows only one null key             |
+--------------------------+----------------------------------------+-----------------------------------------------------------+--------------------------------------------------------+
| LinkedHashMap            | Maintain key insertion order           | Remembers insertion order of keys                         | Slightly slower than HashMap                          |
+--------------------------+----------------------------------------+-----------------------------------------------------------+--------------------------------------------------------+
| TreeMap                  | Sorted map by key                      | Keys are stored in natural or custom sorted order         | No null keys, slower than HashMap                     |
+--------------------------+----------------------------------------+-----------------------------------------------------------+--------------------------------------------------------+
| ArrayDeque / LinkedList  | FIFO queue behavior                    | Supports add/remove at both ends, queue operations        | Not thread-safe, no random access                     |
+--------------------------+----------------------------------------+-----------------------------------------------------------+--------------------------------------------------------+
| PriorityQueue            | Priority-based processing              | Retrieves elements based on priority                      | Order not maintained during iteration, no nulls       |
+--------------------------+----------------------------------------+-----------------------------------------------------------+--------------------------------------------------------+

|-------------------------- Thread-Safe Collections Start Below ---------------------------|

+-------------------------------+----------------------------+--------------------------------------------------------------+
| Collection                    | Type                       | Why It's Suitable                                             |
+-------------------------------+----------------------------+--------------------------------------------------------------+
| CopyOnWriteArrayList          | Thread-safe list           | Safe for concurrent reads/writes, slow on frequent updates   |
+-------------------------------+----------------------------+--------------------------------------------------------------+
| Collections.synchronizedSet() | Thread-safe set            | Wraps any Set (e.g., HashSet) to make it thread-safe         |
+-------------------------------+----------------------------+--------------------------------------------------------------+
| ConcurrentHashMap             | Thread-safe map (modern)   | High-performance, non-blocking access for multi-threaded env |
+-------------------------------+----------------------------+--------------------------------------------------------------+
| Collections.synchronizedMap() | Thread-safe map (legacy)   | Locks entire map; slower and less scalable than ConcurrentHashMap |
+-------------------------------+----------------------------+--------------------------------------------------------------+


93.What is singleton class and how we can make a class singleton?
A Singleton class in Java is a class that allows only one object (instance) to be created throughout the program.
It is used when you want to ensure that only one instance of a class exists globally — for example, in logging, configuration, or DB connection managers.
🔸 Steps to Make a Singleton Class:
Make the constructor private
– So no other class can create an object directly.

Create a private static instance of the class
– This holds the only object.

Provide a public static method to get the instance
– This method returns the single object, and creates it if it doesn’t exist.

public class Singleton {
    // Step 2: private static instance
    private static Singleton instance;

    // Step 1: private constructor
    private Singleton() {
        // private to prevent instantiation
    }

    // Step 3: public method to get the instance
    public static Singleton getInstance() {
        if (instance == null) {
            instance = new Singleton(); // lazy initialization
        }
        return instance;
    }
}



95. What are wrapper classes?

96. What is cloning?

97. What is hash code and equal method?


99. Difference between Collection and Collections?
Collection:
Collection is a interface present in java.util.package. It is used to represent a group ofindividual objects as a single unit.
The List, Set, and Queue are the main sub-interfaces of the collection interface.
The add(), remove(), clear(), size(), and contains() are the important methods of theCollection interface.

Collections:
Collections is a utility class present in java.util.package. It defines several utility staticmethods like sorting and searching which is used to operate on collection.

101.) Explain Collection hierarchy? Explain List, Set and Queue?
Collection Map List Set Queue Priority Queue Hashmap Arraylist Linkedlist Treeset Hashset LinkedHashset

1) List: - list is an interface.
List follows insertion order. It consist of duplicate elements. To use list interface we can use three classes.
i. Arraylist
The ArrayList class is a resizable array, which can be found in the java.util
package.it is internally work like a dynamic array.
ii. Linkedlist
We can use linkedList if there is no continuous memory of location. Adding data is easier than arraylist.it divided into 2 types – i)single LinkedList , ii)Double LinkedList.
iii. vector
It work same as array but it is synchronized and give lower performance than ArrayList

2) Set : Set interface doesn’t follow any insertion order and can’t contain duplicate element.
We can use set interface by 2 classes. 
i.Hashset
It uses hashtable internally.it contains only unique element. It is synchronized and it doesn’t
permit null element. It is the parent class of LinkedHashSet. LinkedHashSet use for remove duplicate element from an array. 

ii.Treeset
It is use for sort data in ascending order.
3) Queue:-
Queue is the parent interface of priority queue. Priority queue is follows FIFO(first in first out) order for adding and removing data. 

102. Difference between ArrayList vs LinkedList and Vector?
ArrayList stores elements in contiguous memory locations, offers fast random access, but is not synchronized.
Whereas, LinkedList does not require contiguous memory, stores data as nodes with pointers, and is better for frequent insertions and deletions, but is also not synchronized.
While, Vector is similar to ArrayList in structure and access speed, but it is synchronized, making it thread-safe but slower in performance.

103. Explain HashSet and HashMap?.
HashMap                                        |--| HashSet
-----------------------------------------------|--|-----------------------------------------------
Stores data as key-value pairs                 |--| Stores data as unique objects (no key-value)
Implements Map interface                       |--| Implements Set interface
Allows one null key and multiple null values   |--| Allows one null element only
Not synchronized by default                    |--| Not synchronized by default
Generally slower due to key-value structure    |--| Generally faster for simple membership tests
Used when mapping keys to values is needed     |--| Used when only uniqueness of elements is required


104. Internal working of HashMap?
It internally uses hashtable. It uses hashcode of the key object and this hashcode used to find index of the bucket.
✅ HashMap internally uses an array of buckets and computes the index using the key’s hashCode(), storing entries with chaining (LinkedList or Tree) and handling collisions using equals().

105. What is Collision and how to overcome this?
It is a situation where two or more key objects produce the same final hash value. To overcome it each bucket consist of linkedlist in it.
Java handles this using chaining (linked list or tree) inside each bucket to store multiple entries.

106. Difference between synchronized hashmap and concurrent hashmap?
Use ConcurrentHashMap for multi-threaded performance;
use Synchronized HashMap only for simple, low-concurrency cases.
🔒 Synchronized HashMap:
It locks the entire map for every operation.
Only one thread can access it at a time.
It's slower and less efficient in multi-threaded environments.
Created using: Collections.synchronizedMap(new HashMap<>()).

⚙️ ConcurrentHashMap:
It locks only parts (segments) of the map.
Multiple threads can read and write safely at the same time.
It is faster and highly scalable.
Built for high-concurrency use.


107. What is Ternary operator with example?
Comparable
comparator
1) Comparable provides a single sorting sequence. In other words, we can sort the
The Comparator provides multiple sorting sequences. In other words, we
collection on the basis of a single element such as id, name, and price.
can sort the collection on the basis of multiple elements such as id, name, and price etc.

108. What are unary operators and its example?
109.Enumeration
Iterator
Only consist read()
Have both methods remove(), read()
Access only vector and hashtable
Access any class in collection.

110. What are association and its type?
The ternary operator is an operator that exists in some programming languages, whichtakes three operands rather than the typical one or two that most operators use.
Ex:- < ,> ,? ,==

111. Difference between Iterator and List Iterator?
which takes one operands i.e. single input it is use to incrementor decrement value.
ex:- ++, --
List iterator is child interface of iterator.
Iterator travel in one direction having method next(), hasNext(). List Iterator travel in both direction having method previous(), hasPrevious(),next(), hasNext().

112. What is Fail fast and fail safe?
An association defines a relationship between two entity objects based on common attributes. The relationship can be one-to-one or one-to-many.


113. code exm of list
public class CollectionFrameworkFullDemo {

    public static void main(String[] args) {

        // 🔹 1. LIST INTERFACE IMPLEMENTATIONS 🔹
        // Lists store elements in insertion order and allow duplicates

        // ✅ ArrayList: Resizable array
        List<String> arrayList = new ArrayList<>();
        arrayList.add("Apple");
        arrayList.add("Banana");
        arrayList.add("Apple"); // duplicates allowed
        System.out.println("ArrayList (allows duplicates, ordered): " + arrayList);

        // ✅ LinkedList: Doubly linked list structure
        List<String> linkedList = new LinkedList<>();
        linkedList.add("Dog");
        linkedList.add("Cat");
        linkedList.add("Dog"); // duplicates allowed
        System.out.println("LinkedList (allows duplicates, ordered): " + linkedList);
    
        System.out.println("--------------------------------------------------------");

        // 🔹 2. SET INTERFACE IMPLEMENTATIONS 🔹
        // Sets store unique elements only, duplicates are not allowed

        // ✅ HashSet: Unordered, unique values only
        Set<String> hashSet = new HashSet<>();
        hashSet.add("Java");
        hashSet.add("Python");
        hashSet.add("Java"); // duplicate will be ignored
        System.out.println("HashSet (no duplicates, unordered): " + hashSet);

        // ✅ LinkedHashSet: Maintains insertion order
        Set<String> linkedHashSet = new LinkedHashSet<>();
        linkedHashSet.add("Mango");
        linkedHashSet.add("Orange");
        linkedHashSet.add("Mango"); // duplicate will be ignored
        System.out.println("LinkedHashSet (insertion order, no duplicates): " + linkedHashSet);

        // ✅ TreeSet: Automatically sorted in natural order
        Set<Integer> treeSet = new TreeSet<>();
        treeSet.add(30);
        treeSet.add(10);
        treeSet.add(20);
        treeSet.add(10); // duplicate ignored
        System.out.println("TreeSet (sorted, no duplicates): " + treeSet);

        System.out.println("--------------------------------------------------------");

        // 🔹 3. QUEUE INTERFACE IMPLEMENTATIONS 🔹
        // Queues follow FIFO (First-In-First-Out) principle

        // ✅ PriorityQueue: Elements are ordered based on natural priority (or custom comparator)
        Queue<Integer> priorityQueue = new PriorityQueue<>();
        priorityQueue.add(40);
        priorityQueue.add(10);
        priorityQueue.add(20);
        System.out.print("PriorityQueue (natural order): ");
        while (!priorityQueue.isEmpty()) {
            System.out.print(priorityQueue.poll() + " ");
        }
        System.out.println();

        // ✅ ArrayDeque: Double-ended queue, faster than LinkedList
        Deque<String> deque = new ArrayDeque<>();
        deque.add("One");
        deque.addFirst("Zero");  // add at beginning
        deque.addLast("Two");    // add at end
        System.out.println("ArrayDeque (FIFO & LIFO supported): " + deque);

        System.out.println("--------------------------------------------------------");

        // 🔹 4. MAP INTERFACE IMPLEMENTATIONS 🔹
        // Maps store key-value pairs, keys are unique, values can repeat

        // ✅ HashMap: Unordered key-value store
        Map<String, Integer> hashMap = new HashMap<>();
        hashMap.put("A", 100);
        hashMap.put("B", 200);
        hashMap.put("A", 300); // replaces value for key "A"
        System.out.println("HashMap (unordered): " + hashMap);

        // ✅ LinkedHashMap: Maintains insertion order
        Map<String, Integer> linkedHashMap = new LinkedHashMap<>();
        linkedHashMap.put("X", 10);
        linkedHashMap.put("Y", 20);
        linkedHashMap.put("X", 30); // replaces value for key "X"
        System.out.println("LinkedHashMap (insertion order): " + linkedHashMap);

        // ✅ TreeMap: Sorted by keys
        Map<String, Integer> treeMap = new TreeMap<>();
        treeMap.put("Banana", 50);
        treeMap.put("Apple", 40);
        treeMap.put("Cherry", 60);
        System.out.println("TreeMap (sorted by keys): " + treeMap);

        System.out.println("--------------------------------------------------------");

        // 🔹 Bonus: Iterate over Map using for-each
        System.out.println("Iterating over TreeMap:");
        for (Map.Entry<String, Integer> entry : treeMap.entrySet()) {
            System.out.println(entry.getKey() + " => " + entry.getValue());
        }
    }
}




